# 葫芦娃大战蛇精最终版
***  
>南京大学计算机系 王森 161220126  
## 效果展示  
![](https://i.imgur.com/9h2AzSl.gif "效果展示")
##开发环境  
| 操作系统 | IDE选择 | 构建环境| GUI框架 |
|:-:|:-:|:-:|:-:|
|Windows 10| JetBrains\IntelliJ IDEA Community Edition 2018.2.3 | Apache Maven 3 | JavaFx |
##功能介绍
### **基本功能：**   
* 两个阵营的对战。
* 多线程调度不同的生物体。
### **新的功能：**  
* 复盘刚结束的战斗。 
* 回放以前的战斗。
* 在用户退出时询问是否保存刚刚的对战，并由用户选择文件路径和文件名对记录进行保存。
* 用户选择不同的阵法，由于不同阵法参与的人数不一样，间接调整了游戏的难度。
* 界面右边添加了实时打印战况的记录栏，打斗过程和战斗结果都会和战斗场景一起实时显示在记录栏中。
* 添加了部分单元测试，对生物移动过程中，生物与每一块地面的从属关系进行了测试；此外，还对阵法变换后，不同生物的参战情况和位置信息进行了测试。
* 通过synchronize关键词的使用，同步了不同线程对临界区数据的访问，避免了数据的不一致性。
## 项目介绍
### 运行说明
* 在终端使用Maven对项目进行编译，单元测试，生成可执行文件。
* 运行target目录下的Calabash-1.0-SNAPSHOT。
* 程序运行时，可以选择开始游戏，并选择双方布阵，按空格键开始对战，游戏结束后，可通过按键R回放刚刚的战斗，也可以通过按键L选择之前的记录文件进行回放。
* 程序运行时，也可以选择回放按钮，选择战斗记录文件，播放以前的战斗记录。
* 程序运行时，点击退出按钮或者右上方×号退出程序，若有战斗完成，则会询问用户是否保存该战斗记录，并由用户选择文件名和保存路径。
* Ps:由于有的阵法涉及人数比较多，开启线程较多，请助教根据个人电脑情况，选择对战方式，否则可能会出现假死状况。
## 代码结构
### package gui
* Main类是整个程序的入口，main方法写在该类中，以开始整个程序。
* GameController类用于在程序逻辑与JavaFx图像逻辑之间同步，传递，调度相关信息。其主要功能在于控制JavaFx的控件并添加相应处理程序;将控件相关参数传递给内部逻辑，并将程序内部逻辑的运行结果显示在图形界面上。
###package battlefield
* Blocks类是整个战场的最小组成部分，战场的每一块土地就是一个Blocks类的对象。每一块土地知道其上面是否站立生物以及站立着什么样的生物。该类上主要实现了两个函数Summon和DeSummon，这两个函数用于召唤某个生物，和赶走某个生物，建立与生物体之间的联系，生物体走到这块地面和离开这块地面，与这两个函数关系紧密。  
![](https://i.imgur.com/LTfXso2.png "Blocks类")
* Battlefield类实现了世界的概念。所有的生物体都生活在这个世界中，世界中的战场由不同的Blocks组成，构成了双方对战的场景。世界中除了人物，还蕴含着各种各样的阵法。该类主要实现开启整个游戏即开启每个生物战斗的线程，初始化人物站位的功能，是GameController类中唯一实例化的类。Battlefield类是一个综合的大类，在该类中聚合了其他类的对象，以调用其他类的功能，来实现世界观的建立，例如：该类中实例化了Record类的成员，用于上帝视角下地记录发生的每一场战斗。该类中所体现的具体设计原则在后面讨论。
###package creatures
* UML图关系  
![](https://i.imgur.com/UBFqJ4o.png "UML类图关系")
* Creatures类是最大的类，名为生物类，所有的生物都是继承该类，并在此基础上添加自己的特有属性的。生物类知晓自己所站立的位置，下一步所要去的位置，自己的长相，自己的名字等等数据信息。生物类中主要实现的方法包括：移步到某个位置，离开某个位置，决策下一步要走向哪个位置（不成熟的AI），与他人进行战斗，若自己战斗落败则牺牲，自己牺牲后一段时间自己的尸体随着时间消失在战场上。Creatures类实现了runnable方法，还需要实现run方法，是该程序中生物线程的基本单位。  
![](https://i.imgur.com/YZetryk.png "Creatures类")
* Grandfather类是爷爷类，继承了Creatures类。
* SheJing类是蛇精类，继承了继承了Creatures类。
* HuLuWa类是葫芦娃类，继承了继承了Creatures类。葫芦娃有自己特有的属性，排行信息。用以区分不同的葫芦娃。
* XieZingJing类是蝎子精类，继承了继承了Creatures类。蝎子精有两种，一种是其他蝎子精的头头，因而不同的蝎子精有不同的地位分工，有的是大哥，有的是小弟。
* HuluBro类将葫芦娃们组织起来，实例化后作为该类的数据成员，便于阵法排布。该类主要实现的功能有：获取某个排行的葫芦娃对象，判断葫芦娃是否全部牺牲。
* LoLo类与HuluBro类相似，只是聚集的对象是蝎子精。
###package form
* Formations接口，定义了所有的阵法，包括鹤翼，雁行，鱼鳞，偃月，锋矢等阵法，但没有给出具体的实现。
![](https://i.imgur.com/PGoL5mX.png "Formations接口")
* Formation类实现了Formations接口，实现了其中的每一个阵法。不同的类可能有不同的实现，这也应证了，学习同样的知识，不同的人有不同的表现的客观事实。
###package replay
* Record类主要实现复盘刚刚结束的战斗，回放以前的战斗，将刚刚结束的战斗以文件的形式保存等功能。  
![](https://i.imgur.com/jkS4c4U.png "Record类")
###resources
* image文件中包含各个生物，背景，死亡的图片。
* MyScene.fxml文件是JavaFx加载的fxml文件，包含用到的所有控件信息。
## 异常处理
### IOException
* 在保存文件和读取文件的时候需要处理IO异常，当调用保存文件方法的函数体捕捉到该异常后打印出错信息，便于调试程序，也不致使程序崩溃。出错的可能原因是文件不存在等。  
![](https://i.imgur.com/HfdN6H8.png "IOException")
### 其他Exception
* 线程控制部分，再将当前线程睡眠时有可能发生异常，因而在睡眠时需要捕捉可能产生的异常，并打印错误信息，以便调试程序，也不致使程序崩溃。  
![](https://i.imgur.com/hqP2eCa.png "其他Exception")
## 单元测试
###采用JUnit进行模块测试。
* TestCreatures类用于测试Creatures类中移步方法的正确性，判断在生物移动到某个位置时，那块土地是否站立着这个生物。
* TestFormation类用于测试Formation类中排好了阵型后，是否按照预想的那样排列，包括判断不该有生物的土地是否有生物，应该有生物的土地是否缺失有生物。
## 设计原则
###SRP 单一职责原则
* 每个类所承担的职责应尽可能的单一。Record类只负责实现复盘和回看功能，不涉及其他功能。Formation类只设计排列不同的阵法，不涉及其他职责。Creatures只设计生物本身的移动，显示等操作，不涉及其他。
###OCP 开放封闭原则
* 对扩展开放，有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。例如当有新的阵法需要加入时，只需添加新的阵法实现即可，而不必修改原来的方法实现。
* 对修改封闭，程序中所涉及的类设计完成，可以独立完成其工作，而不要对类进行任何修改。
### LSP LISKOV替换法则
* Creatures的子类如Grandfather类，HuLuWa类，SheJing类，XieZingJing类都可以替换程序中的Creatures类，而保持程序的功能不变，实现了行为继承。
### ISP 接口隔离原则
* 程序中所涉及的类，若有依赖某些接口，则该接口中的方法都是其所必需的，不会依赖那些不需要的接口，因而遵守了接口隔离原则。
###CARP 合成/聚合复用原则
* Battlefield类中聚合了Blocks类的对象数组，Record类的对象，Grandfather类的对象，SheJing类的对象，HuluBro类的对象，LoLo类的对象，而这些一起构成了游戏的虚拟世界。即世界种有一个N*M的战场，战场由土地块构成，世界中有不同的生物，世界中还有很多的阵法，由不同的生物组合习得，并产生不同的阵法。
* 战场fields由N*M个Blocks对象合成而得。
## 设计模式
### 适配器模式
* Battlefield类中没有实现具体的复盘和回放的功能，但在这个类中会提供接口给GameController类使用，应而通过将一个Record类的对象作为数据成员，而通过这个成员可以访问Record类的接口从而使用回放和复盘的方法。此处采用对象适配器模式。
* 同样是Battlfield类，其中没有实现阵法的形成，但这个世界中存在着阵法，在不implements具体接口的前提下，于是采用继承的方式，继承Formation类，从而在现有的函数中调用继承的Formation中不同的阵法函数。此处采用的是接口适配器模式。
##心得体会
* 通过一学期的学习Java并完成大作业，面向对象编程的思想深入我心。从数据角度出发，对数据进行封装，抽象。
* 好的代码是经过不断重构和迭代出来的，几大设计原则很难都遵守，但是在不断修改的过程中，已经变得比第一版本好了太多。
* 基于现实的抽象才能更好的理解内在逻辑，才能更好的在原有的框架基础上进行扩展和复用。虽然很难将现实世界的逻辑与代码世界的逻辑相统一，但这不断探索的过程是必要的。
